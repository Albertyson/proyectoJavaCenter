/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package paquete;

import java.awt.event.KeyEvent;
import java.io.File;
import java.nio.file.Path;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.text.BadLocationException;

/**
 *
 * @author Alberto
 */
public class FrmConsola extends javax.swing.JFrame {

    /**
     * Creates new form FrmConsola
     */
    public FrmConsola() {
        initComponents();
        currentDir = new File("C:/");
        txtPrincipal.setText("C:\\>");
        this.setExtendedState(this.MAXIMIZED_BOTH);
    }
     public FrmConsola(File usuario) {
        initComponents();
        currentDir = new File("C:/"+usuario.getPath());
        txtPrincipal.setText("C:\\>");
        this.setExtendedState(this.MAXIMIZED_BOTH);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        txtPrincipal = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Consola JCenter");
        setMinimumSize(new java.awt.Dimension(600, 300));
        setResizable(false);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosed(java.awt.event.WindowEvent evt) {
                formWindowClosed(evt);
            }
        });

        txtPrincipal.setBackground(new java.awt.Color(0, 0, 0));
        txtPrincipal.setColumns(20);
        txtPrincipal.setFont(new java.awt.Font("Consolas", 0, 14)); // NOI18N
        txtPrincipal.setForeground(new java.awt.Color(255, 255, 255));
        txtPrincipal.setRows(5);
        txtPrincipal.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                txtPrincipalMouseReleased(evt);
            }
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                txtPrincipalMouseClicked(evt);
            }
            public void mousePressed(java.awt.event.MouseEvent evt) {
                txtPrincipalMousePressed(evt);
            }
        });
        txtPrincipal.addInputMethodListener(new java.awt.event.InputMethodListener() {
            public void caretPositionChanged(java.awt.event.InputMethodEvent evt) {
                txtPrincipalCaretPositionChanged(evt);
            }
            public void inputMethodTextChanged(java.awt.event.InputMethodEvent evt) {
            }
        });
        txtPrincipal.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                txtPrincipalKeyPressed(evt);
            }
        });
        jScrollPane1.setViewportView(txtPrincipal);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 600, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    public void ExceptionComando() throws Exceptions {
        Exceptions e = new Exceptions("No se puede utilizar palabras reservadas como un nombre");
        throw e;
    }
    private void txtPrincipalKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_txtPrincipalKeyPressed
        // TODO add your handling code here:
        if(evt.getKeyCode()==38||evt.getKeyCode()==40){
            evt.consume();
        }
        if(evt.getKeyCode()==37){            
            int posf=txtPrincipal.getSelectionStart()-1;
            if(txtPrincipal.getText().charAt(posf)=='>'){
                evt.consume();
            }            
        }
        if(evt.getKeyCode()==39){            
            
        }
        if(evt.getKeyCode()==8||evt.getKeyCode()==127){//si trata de eliminar el directorio
            linea = "";
            txt = txtPrincipal.getText();
            int nro = txtPrincipal.getLineCount() - 1;
            try {
                for (int i = txtPrincipal.getLineStartOffset(nro); i < txtPrincipal.getLineEndOffset(nro); i++) {
                        linea += txt.charAt(i);//captura la linea
                    }
            } catch (BadLocationException ex) {
                Logger.getLogger(FrmConsola.class.getName()).log(Level.SEVERE, null, ex);
            }
            if(linea.equals(currentDir.getPath() + ">")){
            evt.consume();
            }
            if(txtPrincipal.getText().endsWith(">")){
                evt.consume();
            }
        }
        if (evt.getKeyCode() == 10) {//si la tecla es enter
            evt.consume();//para que no funcione la tecla enter
            linea = "";//limpiar la variable linea
            txt = txtPrincipal.getText();//variable para saber lo que contiene el jTextArea
            int nro = txtPrincipal.getLineCount() - 1;//variable para saber la linea actual del jTextArea
            try {//se requiere para el siguiente for
                for (int i = txtPrincipal.getLineStartOffset(nro); i < txtPrincipal.getLineEndOffset(nro); i++) {
                    linea += txt.charAt(i);//captura la linea
                }
                //si utilizó el comando mkdir
                if (linea.startsWith(currentDir.getPath() + ">mkdir ") || linea.startsWith(currentDir.getPath() + ">MKDIR ")) {
                    CrearCarpeta();
                }//fin de la desicion mk


                //si utilizó el comando cd
                else if (linea.startsWith(currentDir.getPath() + ">cd ") || linea.startsWith(currentDir.getPath() + ">CD ")) {
                    Acceder();
                }//fin del cd

                //si utilizo el comando cd..
                else if (linea.startsWith(currentDir.getPath() + ">cd..") || linea.startsWith(currentDir.getPath() + ">CD..")) {
                    try {
                        currentDir = new File(currentDir.getParent());
                    } catch (Exception ex) {
                    }
                }//fin del cd..

                //si utilizó el comando dir
                else if (linea.startsWith(currentDir.getPath() + ">dir") || linea.startsWith(currentDir.getPath() + ">DIR")) {
                    try {
                        String[] lista = currentDir.list();
                        txtPrincipal.append("\nArchivos y carpetas de " + currentDir.getPath() + "\\\n");
                        for (int i = 0; i < lista.length; i++) {
                            txtPrincipal.append("\t" + lista[i] + "\n");
                        }
                    } catch (Exception ex) {
                    }
                }//fin del comando dir

                //si utilizo el comando rm
                else if (linea.startsWith(currentDir.getPath() + ">rm") || linea.startsWith(currentDir.getPath() + ">RM")) {
                    Eliminar();
                }//fin del comando rm

                //si utilizó el comando date
                else if (linea.startsWith(currentDir.getPath() + ">date") || linea.startsWith(currentDir.getPath() + ">DATE")) {
                    Fecha();
                }//fin del comando date
                
                //si utilizo el comando time
                else if (linea.startsWith(currentDir.getPath() + ">time") || linea.startsWith(currentDir.getPath() + ">TIME")) {
                    Hora();
                }//fin del comando time
                else if (linea.startsWith(currentDir.getPath() + ">clear") || linea.startsWith(currentDir.getPath() + ">CLEAR")) {
                    Limpiar();
                }//fin del comando time
                else if(linea.startsWith(currentDir.getPath() + ">exit") || linea.startsWith(currentDir.getPath() + ">EXIT")){
                    this.dispose();
                }else if(linea.startsWith(currentDir.getPath() + ">absolute") || linea.startsWith(currentDir.getPath() + ">ABSOLUTE")){
                    txtPrincipal.append("\t"+currentDir.getAbsolutePath());
                }
                else{
                    txtPrincipal.append("\tNo se reconoce el comando que ingresó");
                }
            } catch (Exception ex) {
            }
            txtPrincipal.append("\n" + currentDir.getPath() + ">");//
        }
    }//GEN-LAST:event_txtPrincipalKeyPressed

    private void txtPrincipalCaretPositionChanged(java.awt.event.InputMethodEvent evt) {//GEN-FIRST:event_txtPrincipalCaretPositionChanged
        // TODO add your handling code here:
        System.out.println(evt.getCommittedCharacterCount()+"*");
        
    }//GEN-LAST:event_txtPrincipalCaretPositionChanged

    private void txtPrincipalMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_txtPrincipalMouseClicked
        // TODO add your handling code here:
        txtPrincipal.setCaretPosition(txtPrincipal.getText().length());
    }//GEN-LAST:event_txtPrincipalMouseClicked

    private void txtPrincipalMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_txtPrincipalMousePressed
        // TODO add your handling code here:
        txtPrincipal.setCaretPosition(txtPrincipal.getText().length());
    }//GEN-LAST:event_txtPrincipalMousePressed

    private void txtPrincipalMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_txtPrincipalMouseReleased
        // TODO add your handling code here:
        txtPrincipal.setCaretPosition(txtPrincipal.getText().length());
    }//GEN-LAST:event_txtPrincipalMouseReleased

    private void formWindowClosed(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosed
        // TODO add your handling code here:
    }//GEN-LAST:event_formWindowClosed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(FrmConsola.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(FrmConsola.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(FrmConsola.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(FrmConsola.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new FrmConsola().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea txtPrincipal;
    // End of variables declaration//GEN-END:variables
    private File currentDir;//variable para saber el directorio actual
    private String linea = "", txt;

    public void CrearCarpeta() {
        String[] sp = null;//variable para extraer el nombre de la carpeta
        String nom = "";//variable que contendra el nombre de la carpeta
        try {
            //Dependiendo de si escribió el comando en minuscula o en mayuscula
            if (linea.startsWith(currentDir.getPath() + ">mkdir ")) {
                sp = linea.split(">mkdir ");//extraer el nombre
            }
            if (linea.startsWith(currentDir.getPath() + ">MKDIR ")) {
                sp = linea.split(">MKDIR ");//extraer el nombre
            }
            if (sp[1].contains("mkdir") || sp[1].contains("MKDIR")) {
                ExceptionComando();
            }
            nom = sp[1];

            File nuevaCarpeta = new File(currentDir.getPath() + "\\" + nom);//variable para crear una nueva carpeta
            nuevaCarpeta.mkdir();//crear la carpeta
            txtPrincipal.append("\tSe ha creado la carpeta: " + nom);// para saber si se creó
        } catch (Exceptions ex) {//en caso de que el nombre sea un comando
            txtPrincipal.append("\t" + ex.getMessage());
        } catch (Exception e) {//en caso de alguna exception
            txtPrincipal.append("\tNo se reconoce el comando");
        }
    }

    public void Acceder() {
        String[] sp = null;//variable para extraer el nombre de la carpeta
        String nom = "";//variable que contendra el nombre de la carpeta
        try {
            //Dependiendo de si escribió el comando en minuscula o en mayuscula
            if (linea.startsWith(currentDir.getPath() + ">cd ")) {
                sp = linea.split(">cd ");//extraer el nombre
            }
            if (linea.startsWith(currentDir.getPath() + ">CD ")) {
                sp = linea.split(">CD ");//extraer el nombre
            }
            if (sp[1].contains("cd ") || sp[1].contains("CD ")) {
                ExceptionComando();
            }
            nom = sp[1];
            String[] lst = currentDir.list();
            boolean encontro = false;
            for (int i = 0; i < lst.length; i++) {//ciclo para buscar la carpeta en el directorio
                if (lst[i].equals(nom)) {
                    encontro = true;
                    break;
                }
            }
            if (currentDir.isDirectory()) {
                if (encontro) {
                    currentDir = new File(currentDir.getPath() + "\\" + nom + "\\");//posicionarse en la carpeta destino
                } else {
                    txtPrincipal.append("\tNo se encontró la carpeta: " + nom + "\\");// para saber si encontro
                }
            } else {
                txtPrincipal.append("\tNo es una carpeta: ");// cuando no es un directorio
            }
        } catch (Exceptions ex) {//en caso de que el nombre sea un comando
            txtPrincipal.append("\t" + ex.getMessage());
        } catch (Exception e) {//en caso de alguna exception
            txtPrincipal.append("\tNo se reconoce el comando");
        }
    }

    public void Eliminar() {
        String[] sp = null;//variable para extraer el nombre de la carpeta
        String nom = "";//variable que contendra el nombre de la carpeta
        try {
            //Dependiendo de si escribió el comando en minuscula o en mayuscula
            if (linea.startsWith(currentDir.getPath() + ">rm ")) {
                sp = linea.split(">rm ");//extraer el nombre
            }
            if (linea.startsWith(currentDir.getPath() + ">RM ")) {
                sp = linea.split(">RM ");//extraer el nombre
            }
            if (sp[1].contains("rm ") || sp[1].contains("RM ")) {
                ExceptionComando();
            }
            nom = sp[1];
            String[] lst = currentDir.list();
            boolean encontro = false;
            for (int i = 0; i < lst.length; i++) {//ciclo para buscar la carpeta en el directorio
                if (lst[i].equals(nom)) {
                    encontro = true;
                    break;
                }
            }
            if (currentDir.isDirectory()) {//si es una carpeta
                if (encontro) {
                    currentDir = new File(currentDir.getPath() + "\\" + nom + "\\");//colocarse en la carpeta a eliminar
                    if(currentDir.delete()){//si se pudo borrar                        
                    }else{
                        borrarDirectorio(currentDir);//ir al metodo para eliminar directorios interiores
                        currentDir.delete();//eliminar la carpeta ya vacia
                    }
                    currentDir = new File(currentDir.getParent());//colocarse en la carpeta padre de la carpeta eliminada
                    txtPrincipal.append("\tCarpeta " + nom + "\\ eliminada");
                } else {
                    txtPrincipal.append("\tNo se encontró la carpeta: " + nom + "\\");// para saber si encontro
                }
            } else {
                txtPrincipal.append("\tNo es una carpeta: ");// cuando no es un directorio
            }
        } catch (Exceptions ex) {//en caso de que el nombre sea un comando
            txtPrincipal.append("\t" + ex.getMessage());
        } catch (Exception e) {//en caso de alguna exception
            txtPrincipal.append("\tNo se reconoce el comando");
        }
    }

    public void Fecha() {

        String di = "", me = "";
        GregorianCalendar cale = new GregorianCalendar();
        int dia = cale.getTime().getDay(), mes = cale.getTime().getMonth(), anio = cale.getTime().getYear(), ndia=cale.getTime().getDate();
        switch (dia) {
            case 0:
                di = "Domingo";
                break;
            case 1:
                di = "Lunes";
                break;
            case 2:
                di = "Martes";
                break;
            case 3:
                di = "Miércoles";
                break;
            case 4:
                di = "Jueves";
                break;
            case 5:
                di = "Viernes";
                break;
            case 6:
                di = "Sábado";
                break;
        }
        switch (mes) {
            case 0:
                me = "Enero";
                break;
            case 1:
                me = "Febrero";
                break;
            case 2:
                me = "Marzo";
                break;
            case 3:
                me = "Abril";
                break;
            case 4:
                me = "Mayo";
                break;
            case 5:
                me = "Junio";
                break;
            case 6:
                me = "Julio";
                break;
            case 7:
                me = "Agosto";
                break;
            case 8:
                me = "Septiembre";
                break;
            case 9:
                me = "Octubre";
                break;
            case 10:
                me = "Noviembre";
                break;
            case 11:
                me = "Diciembre";
                break;
        }
        anio = anio + 1900;
        txtPrincipal.append("\nFecha: \t" + di +" "+ndia+ "/" + me + "/" + anio);
    }
    public void Hora(){
        Date d=new Date();
        txtPrincipal.append("\nHora Actual:\t"+d.getHours()+":"+d.getMinutes()+":"+d.getSeconds());
    }
    public void Limpiar(){
        txtPrincipal.setText("");
    }
    public void borrarDirectorio(File directorio) {
        File[] ficheros = directorio.listFiles();
        for (int x = 0; x < ficheros.length; x++) {
            if (ficheros[x].isDirectory()) {
                borrarDirectorio(ficheros[x]);
            }
            ficheros[x].delete();
        }
    }
}
